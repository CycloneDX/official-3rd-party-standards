name: Generate Standards JSON Feed

on:
  push:
    branches: [ main ]
  schedule:
    - cron: '0 0 * * *'
  workflow_dispatch:

jobs:
  generate-feed:
    runs-on: ubuntu-latest

    steps:
      - name: Checkout repo
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Install jq
        run: sudo apt-get update && sudo apt-get install -y jq

      - name: Generate JSON Feed
        run: |
          set -eo pipefail

          # ─────────────────────────────────────────────────────────────
          #  updated script (as provided)
          # ─────────────────────────────────────────────────────────────

          # Set the output file path
          feed_path="standards/feed.json"

          # Ensure the directory exists
          mkdir -p "$(dirname "$feed_path")"

          # Function to convert any ISO 8601 timestamp to Zulu format
          to_zulu_time() {
            local timestamp="$1"
            [[ "$timestamp" == *Z ]] && { echo "$timestamp"; return; }

            if date --version >/dev/null 2>&1; then
              date -u -d "$timestamp" "+%Y-%m-%dT%H:%M:%SZ" 2>/dev/null || echo "$timestamp"
            elif command -v gdate >/dev/null 2>&1; then
              gdate -u -d "$timestamp" "+%Y-%m-%dT%H:%M:%SZ" 2>/dev/null || echo "$timestamp"
            elif date -j -f "%Y-%m-%dT%H:%M:%S%z" >/dev/null 2>&1; then
              local formatted
              formatted=$(echo "$timestamp" | sed -E 's/([0-9]{4}-[0-9]{2}-[0-9]{2})T([0-9]{2}:[0-9]{2}:[0-9]{2})([+-][0-9]{2}:[0-9]{2})/\1 \2 \3/')
              date -j -u -f "%Y-%m-%d %H:%M:%S %z" "$formatted" "+%Y-%m-%dT%H:%M:%SZ" 2>/dev/null || echo "$timestamp"
            else
              echo "$timestamp"
            fi
          }

          # Function to determine mime type based on file extension
          get_mime_type() {
            [[ "$1" == *.xml ]] && echo "application/vnd.cyclonedx+xml" || echo "application/vnd.cyclonedx+json"
          }

          # Function to clean serialNumber (remove urn:uuid: prefix)
          clean_serial_number() { echo "$1" | sed 's/^urn:uuid://'; }

          # Create a temporary file for new items
          new_items_file=$(mktemp)
          echo "Created temp file for new items: $new_items_file"

          # Load existing feed (if any)
          if [[ -s "$feed_path" ]]; then
            echo "Found existing feed.json"
            existing_feed=$(cat "$feed_path")
            existing_items=$(jq -c '.items // []' "$feed_path") || existing_items="[]"
          else
            echo "Creating new feed skeleton"
            existing_feed='{
              "version":"https://jsonfeed.org/version/1.1",
              "title":"Open Standards Catalogue",
              "home_page_url":"https://cyclonedx.org/standards",
              "feed_url":"https://cyclonedx.org/standards/feed.json",
              "description":"A feed containing open standards available in the CycloneDX format.",
              "icon":"https://cyclonedx.org/favicon.ico",
              "favicon":"https://cyclonedx.org/favicon.ico",
              "items":[]
            }'
            existing_items="[]"
          fi

          # Check git availability
          git_available=0
          if command -v git >/dev/null 2>&1 && [[ -d .git ]]; then
            git_available=1; echo "Git available for date extraction"
          else
            echo "Git not available; using metadata timestamps"
          fi

          default_date="1970-01-01T00:00:00Z"
          mapfile -t cdx_files < <(find standards -type f -name '*.cdx.json')
          echo "Found ${#cdx_files[@]} CDX files."

          # Process each CDX file
          for filepath in "${cdx_files[@]}"; do
            echo "Processing $filepath"
            external_url="https://raw.githubusercontent.com/CycloneDX/official-3rd-party-standards/main/$filepath"
            mime_type=$(get_mime_type "$filepath")

            # dates
            if (( git_available )); then
              raw_pub=$(git log --diff-filter=A --follow --format=%aI -- "$filepath" | tail -1)
              raw_mod=$(git log -1 --format=%aI -- "$filepath")
            fi
            [[ -z $raw_pub ]] && raw_pub=$(jq -r '.metadata.timestamp // empty' "$filepath")
            [[ -z $raw_mod ]] && raw_mod="$raw_pub"
            [[ -z $raw_pub ]] && raw_pub="$default_date"
            [[ -z $raw_mod ]] && raw_mod="$default_date"

            pub=$(to_zulu_time "$raw_pub")
            mod=$(to_zulu_time "$raw_mod")

            serial_raw=$(jq -r '.serialNumber // empty' "$filepath")
            serial=$(clean_serial_number "$serial_raw")
            bom_ver=$(jq -r '.version // "1"' "$filepath" | awk -F. '{print $1}')

            jq -c \
              --arg url "$external_url" \
              --arg pub "$pub" \
              --arg mod "$mod" \
              --arg mime "$mime_type" \
              --arg sn "$serial" \
              --arg bv "$bom_ver" \
              '
              (.definitions.standards? // [])[] |
              {
                id: (if (.id // "") != "" then .id else (.name | gsub("[^A-Za-z0-9]+";"-") | ascii_downcase) end),
                external_url: $url,
                title: .name,
                content_text: null,
                summary: (.description // ""),
                date_published: $pub,
                date_modified: $mod,
                _metadata: {
                  bomLink: ("urn:cdx:" + $sn + "/" + $bv + "#" + (."bom-ref" // .id)),
                  version: (.version // "1.0"),
                  owner: (.owner // "")
                },
                attachments: [
                  { url: $url, mime_type: $mime }
                ]
              }' "$filepath" >> "$new_items_file"
          done

          echo "All CDX files processed."

          new_items=$(jq -s '.' "$new_items_file")
          new_ids=$(echo "$new_items" | jq -c 'map(.id)')
          filtered_existing=$(echo "$existing_items" | jq --argjson ids "$new_ids" 'map(select(.id as $i | $ids | index($i) | not))')
          existing_map=$(echo "$existing_items" | jq 'map({key:.id,value:.}) | from_entries')
          processed_new=$(echo "$new_items" | jq --argjson m "$existing_map" 'map(if $m[.id] then $m[.id] else . end)')
          combined=$(jq -n --argjson a "$filtered_existing" --argjson b "$processed_new" '$a+$b')
          sorted=$(echo "$combined" | jq 'sort_by(.date_published) | reverse')

          echo "$existing_feed" | jq --argjson items "$sorted" '.items=$items' > "$feed_path"

          if [[ -s "$feed_path" ]]; then
            echo "Feed successfully written to $feed_path"
            echo "Size: $(wc -c <"$feed_path") bytes | Items: $(jq '.items|length' "$feed_path")"
            echo "Items with _metadata: $(jq '.items|map(select(._metadata))|length' "$feed_path")"
            echo "Items with attachments: $(jq '.items|map(select(.attachments))|length' "$feed_path")"
          else
            echo "ERROR: feed file empty." && exit 1
          fi

          rm "$new_items_file"

      - name: Commit and push if changed
        run: |
          git config user.name github-actions
          git config user.email github-actions@github.com

          # Compare actual content changes
          if [[ -f "standards/feed.json" ]]; then
            # Force add to make sure we detect content changes
            git add -f standards/feed.json

            # Check if there are actual changes in content (not just timestamp)
            if git diff --cached --name-only | grep -q "feed.json"; then
              echo "Changes detected in feed.json"
              git commit -m "Update standards JSON feed"
              git push
            else
              echo "No changes detected in feed.json"
            fi
          else
            echo "Feed.json file not found"
            exit 1
          fi
