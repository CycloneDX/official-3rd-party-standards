name: Generate Standards JSON Feed

on:
  schedule:
    - cron: '0 0 * * *'
  workflow_dispatch:

jobs:
  generate-feed:
    runs-on: ubuntu-latest

    steps:
      - name: Checkout repo
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Install jq
        run: sudo apt-get install -y jq

      - name: Generate JSON Feed
        run: |
          set -eo pipefail

          # Set the output file path
          feed_path="standards/feed.json"

          # Ensure the directory exists
          mkdir -p $(dirname "$feed_path")

          # Function to convert any ISO 8601 timestamp to Zulu format
          to_zulu_time() {
            local timestamp="$1"

            # If timestamp is already in Zulu format or empty, return as is
            if [[ "$timestamp" == *Z ]]; then
              echo "$timestamp"
              return
            fi

            # If date command is available with GNU date format
            if date --version >/dev/null 2>&1; then
              # GNU date
              date -u -d "$timestamp" "+%Y-%m-%dT%H:%M:%SZ" 2>/dev/null || echo "$timestamp"
            elif command -v gdate >/dev/null 2>&1; then
              # GNU date installed as gdate (common on macOS)
              gdate -u -d "$timestamp" "+%Y-%m-%dT%H:%M:%SZ" 2>/dev/null || echo "$timestamp"
            elif date -j -f "%Y-%m-%dT%H:%M:%S%z" >/dev/null 2>&1; then
              # BSD date (macOS)
              # Convert timestamp to format date -j can understand
              local formatted_timestamp=$(echo "$timestamp" | sed -E 's/([0-9]{4}-[0-9]{2}-[0-9]{2})T([0-9]{2}:[0-9]{2}:[0-9]{2})([+-][0-9]{2}:[0-9]{2})/\1 \2 \3/')
              date -j -u -f "%Y-%m-%d %H:%M:%S %z" "$formatted_timestamp" "+%Y-%m-%dT%H:%M:%SZ" 2>/dev/null || echo "$timestamp"
            else
              # If we can't convert, return the original
              echo "$timestamp"
            fi
          }

          # Create a temporary file for new items
          new_items_file=$(mktemp)
          echo "Created temp file for new items: $new_items_file"

          # Check if feed.json already exists and load it
          existing_feed=""
          existing_items="{}"
          if [ -f "$feed_path" ] && [ -s "$feed_path" ]; then
            echo "Found existing feed.json, will preserve manual entries"
            existing_feed=$(cat "$feed_path")

            # Try to extract items from existing feed
            existing_items_temp=$(jq -c '.items' "$feed_path" 2>/dev/null || echo "[]")
            if [ "$existing_items_temp" != "null" ] && [ -n "$existing_items_temp" ]; then
              existing_items=$existing_items_temp
              echo "Extracted $(echo "$existing_items" | jq 'length') existing items"
            else
              echo "No valid items found in existing feed.json"
              existing_items="[]"
            fi
          else
            echo "No existing feed.json found, creating new one"
            # Create basic feed structure
            existing_feed='{
              "version": "https://jsonfeed.org/version/1.1",
              "title": "Open Standards Catalogue",
              "home_page_url": "https://cyclonedx.org/standards",
              "feed_url": "https://cyclonedx.org/standards/feed.json",
              "description": "A feed containing open standards available in the CycloneDX format.",
              "icon": "https://cyclonedx.org/favicon.ico",
              "favicon": "https://cyclonedx.org/favicon.ico",
              "items": []
            }'
            existing_items="[]"
          fi

          # Check if git is available
          git_available=0
          if command -v git >/dev/null 2>&1 && [ -d .git ]; then
            git_available=1
            echo "Git is available for date extraction"
          else
            echo "Git is not available, will use metadata fallback"
          fi

          # Find CDX files and extract data
          echo "Looking for CDX files..."
          found_files=$(find standards -type f -name '*.cdx.json' | wc -l)
          echo "Found $found_files CDX files."

          # Default fallback date in Zulu format
          default_date="1970-01-01T00:00:00Z"

          # Process each CDX file
          find standards -type f -name '*.cdx.json' | while read -r filepath; do
            echo "Processing $filepath"
            external_url="https://raw.githubusercontent.com/CycloneDX/official-3rd-party-standards/main/$filepath"

            # Determine dates using git if available
            if [ "$git_available" -eq 1 ]; then
              # First commit date (creation date)
              raw_date_published=$(git log --diff-filter=A --follow --format=%aI -- "$filepath" 2>/dev/null | tail -1)
              # Last update date
              raw_date_modified=$(git log -1 --format=%aI -- "$filepath" 2>/dev/null)

              # If git didn't return dates, use fallbacks
              if [ -z "$raw_date_published" ]; then
                echo "No git creation date found for $filepath, checking metadata..."
                # Try to extract from metadata.timestamp
                raw_date_published=$(jq -r '.metadata.timestamp // empty' "$filepath")
                if [ -z "$raw_date_published" ]; then
                  raw_date_published="$default_date"
                fi
              fi

              if [ -z "$raw_date_modified" ]; then
                # If no modified date, use the published date
                raw_date_modified="$raw_date_published"
              fi
            else
              # No git, use metadata
              raw_date_published=$(jq -r '.metadata.timestamp // empty' "$filepath")
              if [ -z "$raw_date_published" ]; then
                raw_date_published="$default_date"
              fi
              raw_date_modified="$raw_date_published"
            fi

            # Convert dates to Zulu format
            date_published=$(to_zulu_time "$raw_date_published")
            date_modified=$(to_zulu_time "$raw_date_modified")

            # Extract standards definitions with jq
            jq -c \
              --arg url "$external_url" \
              --arg pub "$date_published" \
              --arg mod "$date_modified" \
              '(.definitions.standards? // [])[] | {
                id: (if (.id // "") != "" then .id else (.name | gsub("[^A-Za-z0-9]+"; "-") | ascii_downcase) end),
                external_url: $url,
                title: .name,
                content_text: null,
                summary: (.description // ""),
                date_published: $pub,
                date_modified: $mod,
                tags: (.keywords // [])
              }' "$filepath" >> "$new_items_file"
          done

          echo "All CDX files processed."

          # Create a new items array
          new_items=$(jq -s '.' "$new_items_file")
          echo "Generated $(echo "$new_items" | jq 'length') new items from CDX files."

          # Create a manual step-by-step merge approach
          # 1. Extract IDs from new items
          new_ids=$(echo "$new_items" | jq -c 'map(.id)')

          # 2. Create a filtered list of existing items (keeping those not in new_ids)
          filtered_existing=$(echo "$existing_items" | jq --argjson new_ids "$new_ids" 'map(select(.id as $id | $new_ids | index($id) | not))')

          # 3. Create a map of existing items by ID
          existing_map=$(echo "$existing_items" | jq 'map({key: .id, value: .}) | from_entries')

          # 4. Process new items to use existing versions where available
          processed_new=$(echo "$new_items" | jq --argjson existing_map "$existing_map" 'map(if $existing_map[.id] then $existing_map[.id] else . end)')

          # 5. Combine filtered existing with processed new
          combined=$(echo "$filtered_existing" | jq --argjson processed "$processed_new" '. + $processed')

          # 6. Sort by date_published
          sorted=$(echo "$combined" | jq 'sort_by(.date_published) | reverse')

          # 7. Create the final feed.json
          echo "$existing_feed" | jq --argjson items "$sorted" '.items = $items' > "$feed_path"

          echo "Feed updated with merged items."

          # Verify the file has content
          if [ -s "$feed_path" ]; then
            echo "Feed successfully written to $feed_path"
            echo "File size: $(wc -c < "$feed_path") bytes"
            echo "Number of items: $(jq '.items | length' "$feed_path")"
          else
            echo "Error: Feed file is empty at $feed_path"
            exit 1
          fi

          # Clean up
          rm "$new_items_file"

      - name: Commit and push if changed
        run: |
          git config user.name github-actions
          git config user.email github-actions@github.com
          git add standards/feed.json
          if git diff-index --quiet HEAD; then
            echo "No changes detected."
          else
            git commit -m "Update standards JSON feed"
            git push
          fi
